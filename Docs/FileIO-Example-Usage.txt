// -------------------------------------------------------------------------------------------------------------
// FileIODemonstration.cpp - Comprehensive FileIO Class Usage Documentation and Examples
// 
// This file demonstrates all FileIO class functionality including:
// - Basic file operations (read, write, delete, copy, move, rename)
// - Directory operations
// - Task queue management and priority handling
// - Error handling and status checking
// - Performance monitoring and statistics
// - Thread management
// - PUNPack integration for compression
// -------------------------------------------------------------------------------------------------------------

#include "Includes.h"
#include "FileIO.h"
#include "Debug.h"
#include "ThreadManager.h"

// Enable FileIO debugging output
#if defined(_DEBUG)
#define _DEBUG_FILEIO_DEMO_                                             // Enable FileIO demonstration debugging
#endif

// External references required for FileIO operation
extern Debug debug;
extern ThreadManager threadManager;

// Global FileIO instance for demonstration
FileIO globalFileIO;

//==============================================================================
// FileIO Initialization and Cleanup Demonstration
//==============================================================================

/**
 * Demonstrates proper initialization of the FileIO system
 * This should be called during application startup
 */
bool InitializeFileIOSystem() {
#if defined(_DEBUG_FILEIO_DEMO_) && defined(_DEBUG)
    debug.logLevelMessage(LogLevel::LOG_INFO, L"[DEMO] Starting FileIO system initialization");
#endif

    // Initialize the FileIO subsystem
    if (!globalFileIO.Initialize()) {
#if defined(_DEBUG_FILEIO_DEMO_) && defined(_DEBUG)
        debug.logLevelMessage(LogLevel::LOG_CRITICAL, L"[DEMO] Failed to initialize FileIO system");
#endif
        return false;
    }

    // Start the FileIO processing thread for asynchronous operations
    if (!globalFileIO.StartFileIOThread()) {
#if defined(_DEBUG_FILEIO_DEMO_) && defined(_DEBUG)
        debug.logLevelMessage(LogLevel::LOG_CRITICAL, L"[DEMO] Failed to start FileIO thread");
#endif
        globalFileIO.Cleanup();
        return false;
    }

#if defined(_DEBUG_FILEIO_DEMO_) && defined(_DEBUG)
    debug.logLevelMessage(LogLevel::LOG_INFO, L"[DEMO] FileIO system initialized successfully");
#endif

    return true;
}

/**
 * Demonstrates proper cleanup of the FileIO system
 * This should be called during application shutdown
 */
void CleanupFileIOSystem() {
#if defined(_DEBUG_FILEIO_DEMO_) && defined(_DEBUG)
    debug.logLevelMessage(LogLevel::LOG_INFO, L"[DEMO] Starting FileIO system cleanup");
#endif

    // Stop the FileIO processing thread gracefully
    globalFileIO.StopFileIOThread();

    // Clean up all FileIO resources
    globalFileIO.Cleanup();

#if defined(_DEBUG_FILEIO_DEMO_) && defined(_DEBUG)
    debug.logLevelMessage(LogLevel::LOG_INFO, L"[DEMO] FileIO system cleanup completed");
#endif
}

//==============================================================================
// Basic File Operations Demonstration
//==============================================================================

/**
 * Demonstrates file existence checking with asynchronous processing
 * @param filename - Name of file to check for existence
 * @return true if operation was queued successfully, false otherwise
 */
bool DemonstrateFileExists(const std::string& filename) {
#if defined(_DEBUG_FILEIO_DEMO_) && defined(_DEBUG)
    debug.logDebugMessage(LogLevel::LOG_INFO, L"[DEMO] Checking file existence for: %S", filename.c_str());
#endif

    int taskID = 0;                                                     // Task ID for tracking operation
    bool exists = false;                                                // Variable to receive result (not used in async mode)

    // Queue file existence check with normal priority
    if (!globalFileIO.FileExists(filename, exists, FileIOPriority::PRIORITY_NORMAL, taskID)) {
#if defined(_DEBUG_FILEIO_DEMO_) && defined(_DEBUG)
        debug.logLevelMessage(LogLevel::LOG_ERROR, L"[DEMO] Failed to queue file exists operation");
#endif
        return false;
    }

#if defined(_DEBUG_FILEIO_DEMO_) && defined(_DEBUG)
    debug.logDebugMessage(LogLevel::LOG_INFO, L"[DEMO] File exists check queued with task ID: %d", taskID);
#endif

    // Wait for task completion and check result
    bool taskSuccess = false;                                           // Task completion success status
    bool isReady = false;                                               // Task completion readiness status
    int maxWaitAttempts = 100;                                          // Maximum wait attempts (10 seconds at 100ms intervals)
    int waitAttempts = 0;                                               // Current wait attempt counter

    // Poll for task completion with timeout
    while (waitAttempts < maxWaitAttempts) {
        if (globalFileIO.IsFileIOTaskCompleted(taskID, taskSuccess, isReady)) {
            if (isReady) {
                // Task completed - check success status
                if (taskSuccess) {
#if defined(_DEBUG_FILEIO_DEMO_) && defined(_DEBUG)
                    debug.logDebugMessage(LogLevel::LOG_INFO, L"[DEMO] File exists check completed successfully for task ID: %d", taskID);
#endif
                    // In a real implementation, you would retrieve the result from the task data
                    return true;
                } else {
                    // Task failed - get error information
                    FileIOErrorStatus errorStatus = globalFileIO.GetErrorStatus(taskID);
#if defined(_DEBUG_FILEIO_DEMO_) && defined(_DEBUG)
                    debug.logDebugMessage(LogLevel::LOG_ERROR, L"[DEMO] File exists check failed for task ID: %d, Error: %S", 
                        taskID, std::wstring(errorStatus.errorTypeText.begin(), errorStatus.errorTypeText.end()).c_str());
#endif
                    return false;
                }
            }
        }

        // Sleep briefly before next check to avoid CPU spinning
        std::this_thread::sleep_for(std::chrono::milliseconds(100));
        waitAttempts++;
    }

#if defined(_DEBUG_FILEIO_DEMO_) && defined(_DEBUG)
    debug.logDebugMessage(LogLevel::LOG_WARNING, L"[DEMO] File exists check timed out for task ID: %d", taskID);
#endif

    return false;
}

/**
 * Demonstrates file size retrieval with error handling
 * @param filename - Name of file to get size for
 * @return File size in bytes, or 0 if operation failed
 */
size_t DemonstrateGetFileSize(const std::string& filename) {
#if defined(_DEBUG_FILEIO_DEMO_) && defined(_DEBUG)
    debug.logDebugMessage(LogLevel::LOG_INFO, L"[DEMO] Getting file size for: %S", filename.c_str());
#endif

    int taskID = 0;                                                     // Task ID for tracking operation
    size_t fileSize = 0;                                                // Variable to receive result (not used in async mode)

    // Queue file size retrieval with high priority
    if (!globalFileIO.GetFileSize(filename, fileSize, FileIOPriority::PRIORITY_HIGH, taskID)) {
#if defined(_DEBUG_FILEIO_DEMO_) && defined(_DEBUG)
        debug.logLevelMessage(LogLevel::LOG_ERROR, L"[DEMO] Failed to queue get file size operation");
#endif
        return 0;
    }

#if defined(_DEBUG_FILEIO_DEMO_) && defined(_DEBUG)
    debug.logDebugMessage(LogLevel::LOG_INFO, L"[DEMO] Get file size queued with task ID: %d", taskID);
#endif

    // Implement similar polling logic as in DemonstrateFileExists()
    // For brevity, this is simplified - in production use the full polling implementation
    bool taskSuccess = false;
    bool isReady = false;
    
    // Simple wait loop (production code should use proper timeout handling)
    for (int i = 0; i < 100; i++) {
        if (globalFileIO.IsFileIOTaskCompleted(taskID, taskSuccess, isReady) && isReady) {
            if (taskSuccess) {
#if defined(_DEBUG_FILEIO_DEMO_) && defined(_DEBUG)
                debug.logDebugMessage(LogLevel::LOG_INFO, L"[DEMO] Get file size completed successfully for task ID: %d", taskID);
#endif
                // In a real implementation, you would extract the actual file size from the task result
                return 1024; // Placeholder return value
            } else {
                FileIOErrorStatus errorStatus = globalFileIO.GetErrorStatus(taskID);
#if defined(_DEBUG_FILEIO_DEMO_) && defined(_DEBUG)
                debug.logDebugMessage(LogLevel::LOG_ERROR, L"[DEMO] Get file size failed for task ID: %d, Error: %S", 
                    taskID, std::wstring(errorStatus.errorTypeText.begin(), errorStatus.errorTypeText.end()).c_str());
#endif
                return 0;
            }
        }
        std::this_thread::sleep_for(std::chrono::milliseconds(100));
    }

    return 0;
}

/**
 * Demonstrates file deletion with priority handling
 * @param filename - Name of file to delete
 * @param priority - Priority level for the operation
 * @return true if operation was queued successfully, false otherwise
 */
bool DemonstrateDeleteFile(const std::string& filename, FileIOPriority priority = FileIOPriority::PRIORITY_NORMAL) {
#if defined(_DEBUG_FILEIO_DEMO_) && defined(_DEBUG)
    debug.logDebugMessage(LogLevel::LOG_INFO, L"[DEMO] Deleting file: %S with priority: %d", filename.c_str(), static_cast<int>(priority));
#endif

    int taskID = 0;                                                     // Task ID for tracking operation

    // Queue file deletion with specified priority
    if (!globalFileIO.DeleteFile(filename, priority, taskID)) {
#if defined(_DEBUG_FILEIO_DEMO_) && defined(_DEBUG)
        debug.logLevelMessage(LogLevel::LOG_ERROR, L"[DEMO] Failed to queue delete file operation");
#endif
        return false;
    }

#if defined(_DEBUG_FILEIO_DEMO_) && defined(_DEBUG)
    debug.logDebugMessage(LogLevel::LOG_INFO, L"[DEMO] Delete file queued with task ID: %d", taskID);
#endif

    return true;
}

//==============================================================================
// File Content Operations Demonstration
//==============================================================================

/**
 * Demonstrates writing data to a file with optional compression
 * @param filename - Name of file to write to
 * @param data - Data to write to file
 * @param useCompression - Whether to use PUNPack compression
 * @return true if operation was queued successfully, false otherwise
 */
bool DemonstrateWriteFile(const std::string& filename, const std::vector<uint8_t>& data, bool useCompression = false) {
#if defined(_DEBUG_FILEIO_DEMO_) && defined(_DEBUG)
    debug.logDebugMessage(LogLevel::LOG_INFO, L"[DEMO] Writing file: %S, Data size: %zu, Compression: %s", 
        filename.c_str(), data.size(), useCompression ? L"enabled" : L"disabled");
#endif

    int taskID = 0;                                                     // Task ID for tracking operation

    // Queue stream write operation with normal priority
    if (!globalFileIO.StreamWriteFile(filename, data, useCompression, FileIOPriority::PRIORITY_NORMAL, taskID)) {
#if defined(_DEBUG_FILEIO_DEMO_) && defined(_DEBUG)
        debug.logLevelMessage(LogLevel::LOG_ERROR, L"[DEMO] Failed to queue stream write file operation");
#endif
        return false;
    }

#if defined(_DEBUG_FILEIO_DEMO_) && defined(_DEBUG)
    debug.logDebugMessage(LogLevel::LOG_INFO, L"[DEMO] Stream write file queued with task ID: %d", taskID);
#endif

    return true;
}

/**
 * Demonstrates reading data from a file with optional decompression
 * @param filename - Name of file to read from
 * @param data - Vector to receive read data
 * @param useDecompression - Whether to use PUNPack decompression
 * @return true if operation was queued successfully, false otherwise
 */
bool DemonstrateReadFile(const std::string& filename, std::vector<uint8_t>& data, bool useDecompression = false) {
#if defined(_DEBUG_FILEIO_DEMO_) && defined(_DEBUG)
    debug.logDebugMessage(LogLevel::LOG_INFO, L"[DEMO] Reading file: %S, Decompression: %s", 
        filename.c_str(), useDecompression ? L"enabled" : L"disabled");
#endif

    int taskID = 0;                                                     // Task ID for tracking operation

    // Queue stream read operation with normal priority
    if (!globalFileIO.StreamReadFile(filename, data, useDecompression, FileIOPriority::PRIORITY_NORMAL, taskID)) {
#if defined(_DEBUG_FILEIO_DEMO_) && defined(_DEBUG)
        debug.logLevelMessage(LogLevel::LOG_ERROR, L"[DEMO] Failed to queue stream read file operation");
#endif
        return false;
    }

#if defined(_DEBUG_FILEIO_DEMO_) && defined(_DEBUG)
    debug.logDebugMessage(LogLevel::LOG_INFO, L"[DEMO] Stream read file queued with task ID: %d", taskID);
#endif

    return true;
}

/**
 * Demonstrates appending data to a file at specified position
 * @param filename - Name of file to append to
 * @param data - Data to append
 * @param fileType - Type of file (ASCII or Binary)
 * @param position - Position to append (front or end)
 * @return true if operation was queued successfully, false otherwise
 */
bool DemonstrateAppendToFile(const std::string& filename, const std::vector<uint8_t>& data, 
                            FileIOType fileType, FileIOPosition position) {
#if defined(_DEBUG_FILEIO_DEMO_) && defined(_DEBUG)
    debug.logDebugMessage(LogLevel::LOG_INFO, L"[DEMO] Appending to file: %S, Type: %s, Position: %s, Data size: %zu", 
        filename.c_str(), 
        fileType == FileIOType::TYPE_ASCII ? L"ASCII" : L"Binary",
        position == FileIOPosition::POSITION_FRONT ? L"Front" : L"End",
        data.size());
#endif

    int taskID = 0;                                                     // Task ID for tracking operation

    // Queue append operation with normal priority
    if (!globalFileIO.AppendToFile(filename, data, fileType, position, FileIOPriority::PRIORITY_NORMAL, taskID)) {
#if defined(_DEBUG_FILEIO_DEMO_) && defined(_DEBUG)
        debug.logLevelMessage(LogLevel::LOG_ERROR, L"[DEMO] Failed to queue append to file operation");
#endif
        return false;
    }

#if defined(_DEBUG_FILEIO_DEMO_) && defined(_DEBUG)
    debug.logDebugMessage(LogLevel::LOG_INFO, L"[DEMO] Append to file queued with task ID: %d", taskID);
#endif

    return true;
}

/**
 * Demonstrates deleting a line from an ASCII text file
 * @param filename - Name of ASCII file to modify
 * @param position - Position of line to delete (front or end)
 * @return true if operation was queued successfully, false otherwise
 */
bool DemonstrateDeleteLineInFile(const std::string& filename, FileIOPosition position) {
#if defined(_DEBUG_FILEIO_DEMO_) && defined(_DEBUG)
    debug.logDebugMessage(LogLevel::LOG_INFO, L"[DEMO] Deleting line in file: %S, Position: %s", 
        filename.c_str(), position == FileIOPosition::POSITION_FRONT ? L"Front" : L"End");
#endif

    int taskID = 0;                                                     // Task ID for tracking operation

    // Queue delete line operation with normal priority
    if (!globalFileIO.DeleteLineInFile(filename, position, FileIOPriority::PRIORITY_NORMAL, taskID)) {
#if defined(_DEBUG_FILEIO_DEMO_) && defined(_DEBUG)
        debug.logLevelMessage(LogLevel::LOG_ERROR, L"[DEMO] Failed to queue delete line in file operation");
#endif
        return false;
    }

#if defined(_DEBUG_FILEIO_DEMO_) && defined(_DEBUG)
    debug.logDebugMessage(LogLevel::LOG_INFO, L"[DEMO] Delete line in file queued with task ID: %d", taskID);
#endif

    return true;
}

//==============================================================================
// File Management Operations Demonstration
//==============================================================================

/**
 * Demonstrates copying a file to a new location
 * @param sourceFilename - Source file to copy
 * @param destinationFilename - Destination file name
 * @return true if operation was queued successfully, false otherwise
 */
bool DemonstrateCopyFile(const std::string& sourceFilename, const std::string& destinationFilename) {
#if defined(_DEBUG_FILEIO_DEMO_) && defined(_DEBUG)
    debug.logDebugMessage(LogLevel::LOG_INFO, L"[DEMO] Copying file from: %S to: %S", 
        sourceFilename.c_str(), destinationFilename.c_str());
#endif

    int taskID = 0;                                                     // Task ID for tracking operation

    // Queue copy file operation with normal priority
    if (!globalFileIO.CopyFileTo(sourceFilename, destinationFilename, FileIOPriority::PRIORITY_NORMAL, taskID)) {
#if defined(_DEBUG_FILEIO_DEMO_) && defined(_DEBUG)
        debug.logLevelMessage(LogLevel::LOG_ERROR, L"[DEMO] Failed to queue copy file operation");
#endif
        return false;
    }

#if defined(_DEBUG_FILEIO_DEMO_) && defined(_DEBUG)
    debug.logDebugMessage(LogLevel::LOG_INFO, L"[DEMO] Copy file queued with task ID: %d", taskID);
#endif

    return true;
}

/**
 * Demonstrates moving a file to a new location
 * @param sourceFilename - Source file to move
 * @param destinationPath - Destination directory path
 * @return true if operation was queued successfully, false otherwise
 */
bool DemonstrateMoveFile(const std::string& sourceFilename, const std::string& destinationPath) {
#if defined(_DEBUG_FILEIO_DEMO_) && defined(_DEBUG)
    debug.logDebugMessage(LogLevel::LOG_INFO, L"[DEMO] Moving file from: %S to: %S", 
        sourceFilename.c_str(), destinationPath.c_str());
#endif

    int taskID = 0;                                                     // Task ID for tracking operation

    // Queue move file operation with normal priority
    if (!globalFileIO.MoveFileTo(sourceFilename, destinationPath, FileIOPriority::PRIORITY_NORMAL, taskID)) {
#if defined(_DEBUG_FILEIO_DEMO_) && defined(_DEBUG)
        debug.logLevelMessage(LogLevel::LOG_ERROR, L"[DEMO] Failed to queue move file operation");
#endif
        return false;
    }

#if defined(_DEBUG_FILEIO_DEMO_) && defined(_DEBUG)
    debug.logDebugMessage(LogLevel::LOG_INFO, L"[DEMO] Move file queued with task ID: %d", taskID);
#endif

    return true;
}

/**
 * Demonstrates renaming a file
 * @param currentFilename - Current file name
 * @param newFilename - New file name
 * @return true if operation was queued successfully, false otherwise
 */
bool DemonstrateRenameFile(const std::string& currentFilename, const std::string& newFilename) {
#if defined(_DEBUG_FILEIO_DEMO_) && defined(_DEBUG)
    debug.logDebugMessage(LogLevel::LOG_INFO, L"[DEMO] Renaming file from: %S to: %S", 
        currentFilename.c_str(), newFilename.c_str());
#endif

    int taskID = 0;                                                     // Task ID for tracking operation

    // Queue rename file operation with normal priority
    if (!globalFileIO.RenameFile(currentFilename, newFilename, FileIOPriority::PRIORITY_NORMAL, taskID)) {
#if defined(_DEBUG_FILEIO_DEMO_) && defined(_DEBUG)
        debug.logLevelMessage(LogLevel::LOG_ERROR, L"[DEMO] Failed to queue rename file operation");
#endif
        return false;
    }

#if defined(_DEBUG_FILEIO_DEMO_) && defined(_DEBUG)
    debug.logDebugMessage(LogLevel::LOG_INFO, L"[DEMO] Rename file queued with task ID: %d", taskID);
#endif

    return true;
}

//==============================================================================
// Directory Operations Demonstration
//==============================================================================

/**
 * Demonstrates getting the current directory
 * @param currentPath - String to receive current directory path
 * @return true if operation was queued successfully, false otherwise
 */
bool DemonstrateGetCurrentDirectory(std::string& currentPath) {
#if defined(_DEBUG_FILEIO_DEMO_) && defined(_DEBUG)
    debug.logLevelMessage(LogLevel::LOG_INFO, L"[DEMO] Getting current directory");
#endif

    int taskID = 0;                                                     // Task ID for tracking operation

    // Queue get current directory operation with normal priority
    if (!globalFileIO.GetCurrentDirectory(currentPath, FileIOPriority::PRIORITY_NORMAL, taskID)) {
#if defined(_DEBUG_FILEIO_DEMO_) && defined(_DEBUG)
        debug.logLevelMessage(LogLevel::LOG_ERROR, L"[DEMO] Failed to queue get current directory operation");
#endif
        return false;
    }

#if defined(_DEBUG_FILEIO_DEMO_) && defined(_DEBUG)
    debug.logDebugMessage(LogLevel::LOG_INFO, L"[DEMO] Get current directory queued with task ID: %d", taskID);
#endif

    return true;
}

//==============================================================================
// Advanced Task Management Demonstration
//==============================================================================

/**
 * Demonstrates custom task injection with priority handling
 * @param command - Custom FileIO command to execute
 * @param data - Data buffer for the operation
 * @param useCompression - Whether to use PUNPack compression
 * @param priority - Priority level for the operation
 * @return Task ID if successful, 0 if failed
 */
int DemonstrateCustomTaskInjection(FileIOCommand command, const std::vector<uint8_t>& data, 
                                  bool useCompression, FileIOPriority priority) {
#if defined(_DEBUG_FILEIO_DEMO_) && defined(_DEBUG)
    debug.logDebugMessage(LogLevel::LOG_INFO, L"[DEMO] Injecting custom task - Command: %d, Data size: %zu, Compression: %s, Priority: %d", 
        static_cast<int>(command), data.size(), useCompression ? L"enabled" : L"disabled", static_cast<int>(priority));
#endif

    int taskID = 0;                                                     // Task ID for tracking operation

    // Inject custom task with specified parameters
    if (!globalFileIO.InjectFileIOTask(command, data, useCompression, taskID, priority)) {
#if defined(_DEBUG_FILEIO_DEMO_) && defined(_DEBUG)
        debug.logLevelMessage(LogLevel::LOG_ERROR, L"[DEMO] Failed to inject custom FileIO task");
#endif
        return 0;
    }

#if defined(_DEBUG_FILEIO_DEMO_) && defined(_DEBUG)
    debug.logDebugMessage(LogLevel::LOG_INFO, L"[DEMO] Custom task injected with task ID: %d", taskID);
#endif

    return taskID;
}

/**
 * Demonstrates task completion monitoring with timeout handling
 * @param taskID - ID of task to monitor
 * @param timeoutSeconds - Maximum time to wait for completion
 * @return true if task completed successfully, false if failed or timed out
 */
bool DemonstrateTaskMonitoring(int taskID, int timeoutSeconds = 10) {
#if defined(_DEBUG_FILEIO_DEMO_) && defined(_DEBUG)
    debug.logDebugMessage(LogLevel::LOG_INFO, L"[DEMO] Monitoring task ID: %d with timeout: %d seconds", taskID, timeoutSeconds);
#endif

    bool taskSuccess = false;                                           // Task completion success status
    bool isReady = false;                                               // Task completion readiness status
    int maxWaitAttempts = timeoutSeconds * 10;                         // Maximum wait attempts (100ms intervals)
    int waitAttempts = 0;                                               // Current wait attempt counter

    // Monitor task completion with timeout
    while (waitAttempts < maxWaitAttempts) {
        // Check if task has completed
        if (globalFileIO.IsFileIOTaskCompleted(taskID, taskSuccess, isReady)) {
            if (isReady) {
                // Task completed - check success status
                if (taskSuccess) {
#if defined(_DEBUG_FILEIO_DEMO_) && defined(_DEBUG)
                    debug.logDebugMessage(LogLevel::LOG_INFO, L"[DEMO] Task ID: %d completed successfully", taskID);
#endif
                    return true;
                } else {
                    // Task failed - get detailed error information
                    FileIOErrorStatus errorStatus = globalFileIO.GetErrorStatus(taskID);
#if defined(_DEBUG_FILEIO_DEMO_) && defined(_DEBUG)
                    debug.logDebugMessage(LogLevel::LOG_ERROR, L"[DEMO] Task ID: %d failed - Error Type: %d, Message: %S", 
                        taskID, static_cast<int>(errorStatus.errorTypeCode),
                        std::wstring(errorStatus.errorTypeText.begin(), errorStatus.errorTypeText.end()).c_str());
#endif
                    return false;
                }
            }
        }

        // Sleep briefly before next check to avoid CPU spinning
        std::this_thread::sleep_for(std::chrono::milliseconds(100));
        waitAttempts++;

        // Log progress every second for long-running operations
        if (waitAttempts % 10 == 0) {
#if defined(_DEBUG_FILEIO_DEMO_) && defined(_DEBUG)
            debug.logDebugMessage(LogLevel::LOG_DEBUG, L"[DEMO] Still waiting for task ID: %d (elapsed: %d seconds)", 
                taskID, waitAttempts / 10);
#endif
        }
    }

    // Task timed out
#if defined(_DEBUG_FILEIO_DEMO_) && defined(_DEBUG)
    debug.logDebugMessage(LogLevel::LOG_WARNING, L"[DEMO] Task ID: %d timed out after %d seconds", taskID, timeoutSeconds);
#endif

    return false;
}

//==============================================================================
// Queue Management and Statistics Demonstration
//==============================================================================

/**
 * Demonstrates queue status monitoring and management
 */
void DemonstrateQueueManagement() {
#if defined(_DEBUG_FILEIO_DEMO_) && defined(_DEBUG)
    debug.logLevelMessage(LogLevel::LOG_INFO, L"[DEMO] Demonstrating queue management operations");
#endif

    // Get current queue size
    size_t queueSize = globalFileIO.GetQueueSize();
#if defined(_DEBUG_FILEIO_DEMO_) && defined(_DEBUG)
    debug.logDebugMessage(LogLevel::LOG_INFO, L"[DEMO] Current queue size: %zu tasks", queueSize);
#endif

    // Check if queue is empty
    bool isEmpty = globalFileIO.IsQueueEmpty();
#if defined(_DEBUG_FILEIO_DEMO_) && defined(_DEBUG)
    debug.logDebugMessage(LogLevel::LOG_INFO, L"[DEMO] Queue empty status: %s", isEmpty ? L"true" : L"false");
#endif

    // Demonstrate queue clearing (use with caution in production)
    if (queueSize > 50) { // Only clear if queue is getting large
#if defined(_DEBUG_FILEIO_DEMO_) && defined(_DEBUG)
        debug.logLevelMessage(LogLevel::LOG_WARNING, L"[DEMO] Queue size exceeds threshold, clearing queue");
#endif
        globalFileIO.ClearQueue();
        
        size_t newQueueSize = globalFileIO.GetQueueSize();
#if defined(_DEBUG_FILEIO_DEMO_) && defined(_DEBUG)
        debug.logDebugMessage(LogLevel::LOG_INFO, L"[DEMO] Queue cleared - New size: %zu tasks", newQueueSize);
#endif
    }
}

/**
 * Demonstrates performance statistics monitoring
 */
void DemonstrateStatisticsMonitoring() {
#if defined(_DEBUG_FILEIO_DEMO_) && defined(_DEBUG)
    debug.logLevelMessage(LogLevel::LOG_INFO, L"[DEMO] Demonstrating statistics monitoring");
#endif

    // Get current performance statistics
    FileIO::FileIOStatistics stats = globalFileIO.GetStatistics();

    // Log comprehensive statistics information
#if defined(_DEBUG_FILEIO_DEMO_) && defined(_DEBUG)
    debug.logDebugMessage(LogLevel::LOG_INFO, L"[DEMO] FileIO Statistics:");
    debug.logDebugMessage(LogLevel::LOG_INFO, L"[DEMO]   Total Tasks Processed: %llu", stats.totalTasksProcessed);
    debug.logDebugMessage(LogLevel::LOG_INFO, L"[DEMO]   Total Tasks Successful: %llu", stats.totalTasksSuccessful);
    debug.logDebugMessage(LogLevel::LOG_INFO, L"[DEMO]   Total Tasks Failed: %llu", stats.totalTasksFailed);
    debug.logDebugMessage(LogLevel::LOG_INFO, L"[DEMO]   Total Bytes Read: %llu", stats.totalBytesRead);
    debug.logDebugMessage(LogLevel::LOG_INFO, L"[DEMO]   Total Bytes Written: %llu", stats.totalBytesWritten);
    debug.logDebugMessage(LogLevel::LOG_INFO, L"[DEMO]   Average Processing Time: %.2f ms", stats.averageTaskProcessingTime);
#endif

    // Calculate success rate if any tasks have been processed
    if (stats.totalTasksProcessed > 0) {
        float successRate = (static_cast<float>(stats.totalTasksSuccessful) / 
                            static_cast<float>(stats.totalTasksProcessed)) * 100.0f;
#if defined(_DEBUG_FILEIO_DEMO_) && defined(_DEBUG)
        debug.logDebugMessage(LogLevel::LOG_INFO, L"[DEMO]   Success Rate: %.2f%%", successRate);
#endif
    }

    // Calculate session duration
    auto currentTime = std::chrono::steady_clock::now();
    auto sessionDuration = std::chrono::duration_cast<std::chrono::seconds>(currentTime - stats.sessionStartTime);
#if defined(_DEBUG_FILEIO_DEMO_) && defined(_DEBUG)
    debug.logDebugMessage(LogLevel::LOG_INFO, L"[DEMO]   Session Duration: %lld seconds", sessionDuration.count());
#endif
}

/**
 * Demonstrates statistics reset functionality
 */
void DemonstrateStatisticsReset() {
#if defined(_DEBUG_FILEIO_DEMO_) && defined(_DEBUG)
    debug.logLevelMessage(LogLevel::LOG_INFO, L"[DEMO] Resetting FileIO statistics");
#endif

    // Reset all performance statistics
    globalFileIO.ResetStatistics();

    // Verify statistics have been reset
    FileIO::FileIOStatistics stats = globalFileIO.GetStatistics();
#if defined(_DEBUG_FILEIO_DEMO_) && defined(_DEBUG)
    debug.logDebugMessage(LogLevel::LOG_INFO, L"[DEMO] Statistics after reset - Total tasks: %llu, Success: %llu, Failed: %llu", 
        stats.totalTasksProcessed, stats.totalTasksSuccessful, stats.totalTasksFailed);
#endif
}

//==============================================================================
// Thread Management Demonstration
//==============================================================================

/**
 * Demonstrates thread status monitoring and control
 */
void DemonstrateThreadManagement() {
#if defined(_DEBUG_FILEIO_DEMO_) && defined(_DEBUG)
    debug.logLevelMessage(LogLevel::LOG_INFO, L"[DEMO] Demonstrating thread management operations");
#endif

    // Check if FileIO thread is currently running
    bool isRunning = globalFileIO.IsThreadRunning();
#if defined(_DEBUG_FILEIO_DEMO_) && defined(_DEBUG)
    debug.logDebugMessage(LogLevel::LOG_INFO, L"[DEMO] FileIO thread running status: %s", isRunning ? L"true" : L"false");
#endif

    if (!isRunning) {
        // Start thread if not running
#if defined(_DEBUG_FILEIO_DEMO_) && defined(_DEBUG)
        debug.logLevelMessage(LogLevel::LOG_INFO, L"[DEMO] Starting FileIO thread");
#endif
        
        if (globalFileIO.StartFileIOThread()) {
#if defined(_DEBUG_FILEIO_DEMO_) && defined(_DEBUG)
            debug.logLevelMessage(LogLevel::LOG_INFO, L"[DEMO] FileIO thread started successfully");
#endif
        } else {
#if defined(_DEBUG_FILEIO_DEMO_) && defined(_DEBUG)
            debug.logLevelMessage(LogLevel::LOG_ERROR, L"[DEMO] Failed to start FileIO thread");
#endif
        }
    }

    // Demonstrate graceful thread stopping (only for demonstration - normally done at shutdown)
    /*
    if (isRunning) {
#if defined(_DEBUG_FILEIO_DEMO_) && defined(_DEBUG)
        debug.logLevelMessage(LogLevel::LOG_INFO, L"[DEMO] Stopping FileIO thread for demonstration");
#endif
        
        globalFileIO.StopFileIOThread();
        
#if defined(_DEBUG_FILEIO_DEMO_) && defined(_DEBUG)
        debug.logLevelMessage(LogLevel::LOG_INFO, L"[DEMO] FileIO thread stopped");
#endif
    }
    */
}

//==============================================================================
// Error Handling and Recovery Demonstration
//==============================================================================

/**
 * Demonstrates comprehensive error handling for FileIO operations
 * @param taskID - Task ID to check for errors
 */
void DemonstrateErrorHandling(int taskID) {
#if defined(_DEBUG_FILEIO_DEMO_) && defined(_DEBUG)
    debug.logDebugMessage(LogLevel::LOG_INFO, L"[DEMO] Demonstrating error handling for task ID: %d", taskID);
#endif

    // Get detailed error status for the task
    FileIOErrorStatus errorStatus = globalFileIO.GetErrorStatus(taskID);

    // Check if error information is available
    if (errorStatus.errorTypeCode != FileIOErrorType::ERROR_NONE) {
#if defined(_DEBUG_FILEIO_DEMO_) && defined(_DEBUG)
        debug.logDebugMessage(LogLevel::LOG_ERROR, L"[DEMO] Error detected for task ID: %d", taskID);
        debug.logDebugMessage(LogLevel::LOG_ERROR, L"[DEMO]   Error Type Code: %d", static_cast<int>(errorStatus.errorTypeCode));
        debug.logDebugMessage(LogLevel::LOG_ERROR, L"[DEMO]   Error Description: %S", 
            std::wstring(errorStatus.errorTypeText.begin(), errorStatus.errorTypeText.end()).c_str());
        debug.logDebugMessage(LogLevel::LOG_ERROR, L"[DEMO]   Affected Filename: %S", 
            std::wstring(errorStatus.filename.begin(), errorStatus.filename.end()).c_str());
        debug.logDebugMessage(LogLevel::LOG_ERROR, L"[DEMO]   Affected Directory: %S", 
            std::wstring(errorStatus.directory.begin(), errorStatus.directory.end()).c_str());
        debug.logDebugMessage(LogLevel::LOG_ERROR, L"[DEMO]   Command Type: %d", static_cast<int>(errorStatus.taskCommand));
        debug.logDebugMessage(LogLevel::LOG_ERROR, L"[DEMO]   Platform Error Code: %u", errorStatus.platformErrorCode);
        debug.logDebugMessage(LogLevel::LOG_ERROR, L"[DEMO]   Platform Error Message: %S", 
            std::wstring(errorStatus.platformErrorMessage.begin(), errorStatus.platformErrorMessage.end()).c_str());
#endif

        // Demonstrate error recovery strategies based on error type
        switch (errorStatus.errorTypeCode) {
            case FileIOErrorType::ERROR_FILE_NOTFOUND:
#if defined(_DEBUG_FILEIO_DEMO_) && defined(_DEBUG)
                debug.logLevelMessage(LogLevel::LOG_INFO, L"[DEMO] Recovery suggestion: Verify file path and existence");
#endif
                break;

            case FileIOErrorType::ERROR_ACCESSDENIED:
#if defined(_DEBUG_FILEIO_DEMO_) && defined(_DEBUG)
                debug.logLevelMessage(LogLevel::LOG_INFO, L"[DEMO] Recovery suggestion: Check file permissions and administrative rights");
#endif
                break;

            case FileIOErrorType::ERROR_DISKFULL:
#if defined(_DEBUG_FILEIO_DEMO_) && defined(_DEBUG)
                debug.logLevelMessage(LogLevel::LOG_INFO, L"[DEMO] Recovery suggestion: Free disk space or use alternative storage location");
#endif
                break;

            case FileIOErrorType::ERROR_FILE_LOCKED:
#if defined(_DEBUG_FILEIO_DEMO_) && defined(_DEBUG)
                debug.logLevelMessage(LogLevel::LOG_INFO, L"[DEMO] Recovery suggestion: Wait for file to be released or close other applications");
#endif
                break;

            case FileIOErrorType::ERROR_PUNPACK_FAILED:
#if defined(_DEBUG_FILEIO_DEMO_) && defined(_DEBUG)
                debug.logLevelMessage(LogLevel::LOG_INFO, L"[DEMO] Recovery suggestion: Retry without compression or check data integrity");
#endif
                break;

            default:
#if defined(_DEBUG_FILEIO_DEMO_) && defined(_DEBUG)
                debug.logLevelMessage(LogLevel::LOG_INFO, L"[DEMO] Recovery suggestion: Retry operation or contact support");
#endif
                break;
        }
    } else {
#if defined(_DEBUG_FILEIO_DEMO_) && defined(_DEBUG)
        debug.logDebugMessage(LogLevel::LOG_INFO, L"[DEMO] No error information available for task ID: %d", taskID);
#endif
    }
}

//==============================================================================
// Priority Handling Demonstration
//==============================================================================

/**
 * Demonstrates priority-based task processing
 */
void DemonstratePriorityHandling() {
#if defined(_DEBUG_FILEIO_DEMO_) && defined(_DEBUG)
    debug.logLevelMessage(LogLevel::LOG_INFO, L"[DEMO] Demonstrating priority-based task processing");
#endif

    // Create sample data for demonstration
    std::vector<uint8_t> sampleData = {'H', 'e', 'l', 'l', 'o', ' ', 'W', 'o', 'r', 'l', 'd', '!'};

    // Queue tasks with different priorities to demonstrate processing order
    int lowPriorityTask = 0;
    int normalPriorityTask = 0;
    int highPriorityTask = 0;
    int criticalPriorityTask = 0;

    // Queue low priority task first
    if (globalFileIO.StreamWriteFile("demo_low_priority.txt", sampleData, false, 
                                    FileIOPriority::PRIORITY_LOW, lowPriorityTask)) {
#if defined(_DEBUG_FILEIO_DEMO_) && defined(_DEBUG)
        debug.logDebugMessage(LogLevel::LOG_INFO, L"[DEMO] Low priority task queued with ID: %d", lowPriorityTask);
#endif
    }

    // Queue normal priority task second
    if (globalFileIO.StreamWriteFile("demo_normal_priority.txt", sampleData, false, 
                                    FileIOPriority::PRIORITY_NORMAL, normalPriorityTask)) {
#if defined(_DEBUG_FILEIO_DEMO_) && defined(_DEBUG)
        debug.logDebugMessage(LogLevel::LOG_INFO, L"[DEMO] Normal priority task queued with ID: %d", normalPriorityTask);
#endif
    }

    // Queue high priority task third
    if (globalFileIO.StreamWriteFile("demo_high_priority.txt", sampleData, false, 
                                    FileIOPriority::PRIORITY_HIGH, highPriorityTask)) {
#if defined(_DEBUG_FILEIO_DEMO_) && defined(_DEBUG)
        debug.logDebugMessage(LogLevel::LOG_INFO, L"[DEMO] High priority task queued with ID: %d", highPriorityTask);
#endif
    }

    // Queue critical priority task last
    if (globalFileIO.StreamWriteFile("demo_critical_priority.txt", sampleData, false, 
                                    FileIOPriority::PRIORITY_CRITICAL, criticalPriorityTask)) {
#if defined(_DEBUG_FILEIO_DEMO_) && defined(_DEBUG)
        debug.logDebugMessage(LogLevel::LOG_INFO, L"[DEMO] Critical priority task queued with ID: %d", criticalPriorityTask);
#endif
    }

#if defined(_DEBUG_FILEIO_DEMO_) && defined(_DEBUG)
    debug.logLevelMessage(LogLevel::LOG_INFO, L"[DEMO] Tasks should process in order: Critical, High, Normal, Low");
    debug.logLevelMessage(LogLevel::LOG_INFO, L"[DEMO] Monitor the debug output to verify priority processing order");
#endif
}

/**
 * Demonstrates checking for pending write operations
 */
void DemonstratePendingWriteTaskMonitoring() {
#if defined(_DEBUG_FILEIO_DEMO_) && defined(_DEBUG)
    debug.logLevelMessage(LogLevel::LOG_INFO, L"[DEMO] Demonstrating pending write task monitoring");
#endif

    // Check initial state before queuing any write operations
    bool initialHasPendingWrites = globalFileIO.HasPendingWriteTasks();
    size_t initialWriteCount = globalFileIO.GetPendingWriteTaskCount();

#if defined(_DEBUG_FILEIO_DEMO_) && defined(_DEBUG)
    debug.logDebugMessage(LogLevel::LOG_INFO, L"[DEMO] Initial state - Has pending writes: %s, Write count: %zu",
        initialHasPendingWrites ? L"true" : L"false", initialWriteCount);
#endif

    // Create sample data for write operations
    std::vector<uint8_t> sampleData = {'T', 'e', 's', 't', ' ', 'W', 'r', 'i', 't', 'e', ' ', 'D', 'a', 't', 'a'};

    // Queue several write operations
    int writeTask1 = 0, writeTask2 = 0, writeTask3 = 0;
    
    globalFileIO.StreamWriteFile("pending_test1.txt", sampleData, false, FileIOPriority::PRIORITY_NORMAL, writeTask1);
    globalFileIO.StreamWriteFile("pending_test2.txt", sampleData, true, FileIOPriority::PRIORITY_HIGH, writeTask2);
    globalFileIO.AppendToFile("pending_test1.txt", sampleData, FileIOType::TYPE_ASCII, 
                              FileIOPosition::POSITION_END, FileIOPriority::PRIORITY_NORMAL, writeTask3);

    // Check pending write status after queuing operations
    bool hasPendingWrites = globalFileIO.HasPendingWriteTasks();
    size_t writeCount = globalFileIO.GetPendingWriteTaskCount();

#if defined(_DEBUG_FILEIO_DEMO_) && defined(_DEBUG)
    debug.logDebugMessage(LogLevel::LOG_INFO, L"[DEMO] After queuing writes - Has pending writes: %s, Write count: %zu",
        hasPendingWrites ? L"true" : L"false", writeCount);
    debug.logDebugMessage(LogLevel::LOG_INFO, L"[DEMO] Queued write task IDs: %d, %d, %d", writeTask1, writeTask2, writeTask3);
#endif

    // Monitor write task completion over time
    int monitorAttempts = 0;
    const int maxMonitorAttempts = 50;                                  // Monitor for up to 5 seconds

    while (monitorAttempts < maxMonitorAttempts) {
        bool currentHasPendingWrites = globalFileIO.HasPendingWriteTasks();
        size_t currentWriteCount = globalFileIO.GetPendingWriteTaskCount();

        if (currentWriteCount != writeCount) {
            // Write task count changed - log the update
#if defined(_DEBUG_FILEIO_DEMO_) && defined(_DEBUG)
            debug.logDebugMessage(LogLevel::LOG_INFO, L"[DEMO] Write task progress - Previous count: %zu, Current count: %zu",
                writeCount, currentWriteCount);
#endif
            writeCount = currentWriteCount;
        }

        // Break if all write tasks completed
        if (!currentHasPendingWrites) {
#if defined(_DEBUG_FILEIO_DEMO_) && defined(_DEBUG)
            debug.logLevelMessage(LogLevel::LOG_INFO, L"[DEMO] All write tasks completed successfully");
#endif
            break;
        }

        // Sleep briefly before next check
        std::this_thread::sleep_for(std::chrono::milliseconds(100));
        monitorAttempts++;
    }

    // Final status check
    bool finalHasPendingWrites = globalFileIO.HasPendingWriteTasks();
    size_t finalWriteCount = globalFileIO.GetPendingWriteTaskCount();

#if defined(_DEBUG_FILEIO_DEMO_) && defined(_DEBUG)
    debug.logDebugMessage(LogLevel::LOG_INFO, L"[DEMO] Final state - Has pending writes: %s, Write count: %zu",
        finalHasPendingWrites ? L"true" : L"false", finalWriteCount);
#endif

    if (finalHasPendingWrites) {
#if defined(_DEBUG_FILEIO_DEMO_) && defined(_DEBUG)
        debug.logLevelMessage(LogLevel::LOG_WARNING, L"[DEMO] Some write tasks may still be pending completion");
#endif
    }
}

//==============================================================================
// Compression Integration Demonstration
//==============================================================================

/**
 * Demonstrates PUNPack compression integration with FileIO operations
 */
void DemonstrateCompressionIntegration() {
#if defined(_DEBUG_FILEIO_DEMO_) && defined(_DEBUG)
    debug.logLevelMessage(LogLevel::LOG_INFO, L"[DEMO] Demonstrating PUNPack compression integration");
#endif

    // Create larger sample data for meaningful compression demonstration
    std::vector<uint8_t> largeData;
    std::string repeatedText = "This is a sample text for compression testing. ";
    for (int i = 0; i < 100; i++) {                                    // Repeat text 100 times for better compression ratio
        largeData.insert(largeData.end(), repeatedText.begin(), repeatedText.end());
    }

#if defined(_DEBUG_FILEIO_DEMO_) && defined(_DEBUG)
    debug.logDebugMessage(LogLevel::LOG_INFO, L"[DEMO] Original data size: %zu bytes", largeData.size());
#endif

    // Write data with compression enabled
    int compressedWriteTask = 0;
    if (globalFileIO.StreamWriteFile("demo_compressed.dat", largeData, true, 
                                    FileIOPriority::PRIORITY_NORMAL, compressedWriteTask)) {
#if defined(_DEBUG_FILEIO_DEMO_) && defined(_DEBUG)
        debug.logDebugMessage(LogLevel::LOG_INFO, L"[DEMO] Compressed write task queued with ID: %d", compressedWriteTask);
#endif

        // Wait for compression task to complete
        if (DemonstrateTaskMonitoring(compressedWriteTask, 15)) {
            // Read data back with decompression enabled
            std::vector<uint8_t> decompressedData;
            int decompressedReadTask = 0;
            
            if (globalFileIO.StreamReadFile("demo_compressed.dat", decompressedData, true, 
                                          FileIOPriority::PRIORITY_NORMAL, decompressedReadTask)) {
#if defined(_DEBUG_FILEIO_DEMO_) && defined(_DEBUG)
                debug.logDebugMessage(LogLevel::LOG_INFO, L"[DEMO] Decompressed read task queued with ID: %d", decompressedReadTask);
#endif

                // Wait for decompression task to complete
                if (DemonstrateTaskMonitoring(decompressedReadTask, 15)) {
#if defined(_DEBUG_FILEIO_DEMO_) && defined(_DEBUG)
                    debug.logLevelMessage(LogLevel::LOG_INFO, L"[DEMO] Compression/decompression cycle completed successfully");
                    debug.logLevelMessage(LogLevel::LOG_INFO, L"[DEMO] Data integrity can be verified by comparing original and decompressed data");
#endif
                }
            }
        }
    }

    // Demonstrate compression with custom task injection
    int customCompressionTask = DemonstrateCustomTaskInjection(FileIOCommand::CMD_STREAM_WRITE_FILE, 
                                                              largeData, true, FileIOPriority::PRIORITY_HIGH);
    if (customCompressionTask > 0) {
#if defined(_DEBUG_FILEIO_DEMO_) && defined(_DEBUG)
        debug.logDebugMessage(LogLevel::LOG_INFO, L"[DEMO] Custom compression task injected with ID: %d", customCompressionTask);
#endif
    }
}

//==============================================================================
// Complete Usage Example and Main Demonstration Function
//==============================================================================

/**
 * Comprehensive demonstration of all FileIO class functionality
 * This function showcases the complete usage workflow
 */
void CompleteFileIODemonstration() {
#if defined(_DEBUG_FILEIO_DEMO_) && defined(_DEBUG)
    debug.logLevelMessage(LogLevel::LOG_INFO, L"[DEMO] Starting comprehensive FileIO demonstration");
#endif

    // Step 1: Initialize FileIO system
    if (!InitializeFileIOSystem()) {
#if defined(_DEBUG_FILEIO_DEMO_) && defined(_DEBUG)
        debug.logLevelMessage(LogLevel::LOG_CRITICAL, L"[DEMO] Failed to initialize FileIO system - aborting demonstration");
#endif
        return;
    }

    // Step 2: Demonstrate basic file operations
#if defined(_DEBUG_FILEIO_DEMO_) && defined(_DEBUG)
    debug.logLevelMessage(LogLevel::LOG_INFO, L"[DEMO] === BASIC FILE OPERATIONS ===");
#endif

    // Check if a file exists
    DemonstrateFileExists("test_file.txt");

    // Get file size
    size_t fileSize = DemonstrateGetFileSize("test_file.txt");

    // Create sample data for file operations
    std::vector<uint8_t> sampleData = {'T', 'e', 's', 't', ' ', 'D', 'a', 't', 'a'};

    // Write data to file
    DemonstrateWriteFile("demo_output.txt", sampleData, false);

    // Read data from file
    std::vector<uint8_t> readData;
    DemonstrateReadFile("demo_output.txt", readData, false);

    // Step 3: Demonstrate file management operations
#if defined(_DEBUG_FILEIO_DEMO_) && defined(_DEBUG)
    debug.logLevelMessage(LogLevel::LOG_INFO, L"[DEMO] === FILE MANAGEMENT OPERATIONS ===");
#endif

    // Copy file
    DemonstrateCopyFile("demo_output.txt", "demo_copy.txt");

    // Rename file
    DemonstrateRenameFile("demo_copy.txt", "demo_renamed.txt");

    // Move file
    DemonstrateMoveFile("demo_renamed.txt", "./backup/demo_moved.txt");

    // Step 4: Demonstrate directory operations
#if defined(_DEBUG_FILEIO_DEMO_) && defined(_DEBUG)
    debug.logLevelMessage(LogLevel::LOG_INFO, L"[DEMO] === DIRECTORY OPERATIONS ===");
#endif

    std::string currentDir;
    DemonstrateGetCurrentDirectory(currentDir);

    // Step 5: Demonstrate advanced content operations
#if defined(_DEBUG_FILEIO_DEMO_) && defined(_DEBUG)
    debug.logLevelMessage(LogLevel::LOG_INFO, L"[DEMO] === ADVANCED CONTENT OPERATIONS ===");
#endif

    // Append data to file
    std::vector<uint8_t> appendData = {'\n', 'A', 'p', 'p', 'e', 'n', 'd', 'e', 'd'};
    DemonstrateAppendToFile("demo_output.txt", appendData, FileIOType::TYPE_ASCII, FileIOPosition::POSITION_END);

    // Delete line from file
    DemonstrateDeleteLineInFile("demo_output.txt", FileIOPosition::POSITION_FRONT);

    // Step 6: Demonstrate priority handling
#if defined(_DEBUG_FILEIO_DEMO_) && defined(_DEBUG)
    debug.logLevelMessage(LogLevel::LOG_INFO, L"[DEMO] === PRIORITY HANDLING ===");
#endif

    DemonstratePriorityHandling();

    // Step 7: Demonstrate compression integration
#if defined(_DEBUG_FILEIO_DEMO_) && defined(_DEBUG)
    debug.logLevelMessage(LogLevel::LOG_INFO, L"[DEMO] === COMPRESSION INTEGRATION ===");
#endif

    DemonstrateCompressionIntegration();

    // Step 8: Demonstrate queue and thread management
#if defined(_DEBUG_FILEIO_DEMO_) && defined(_DEBUG)
    debug.logLevelMessage(LogLevel::LOG_INFO, L"[DEMO] === QUEUE AND THREAD MANAGEMENT ===");
#endif

    DemonstrateQueueManagement();
    DemonstrateThreadManagement();

    // Step 9: Demonstrate statistics monitoring
#if defined(_DEBUG_FILEIO_DEMO_) && defined(_DEBUG)
    debug.logLevelMessage(LogLevel::LOG_INFO, L"[DEMO] === STATISTICS MONITORING ===");
#endif

    DemonstrateStatisticsMonitoring();

    // Step 10: Wait for all operations to complete
#if defined(_DEBUG_FILEIO_DEMO_) && defined(_DEBUG)
    debug.logLevelMessage(LogLevel::LOG_INFO, L"[DEMO] === WAITING FOR TASK COMPLETION ===");
#endif

    // Allow time for all queued operations to complete
    std::this_thread::sleep_for(std::chrono::seconds(5));

    // Get final statistics
    DemonstrateStatisticsMonitoring();

    // Step 11: Cleanup (normally done at application shutdown)
#if defined(_DEBUG_FILEIO_DEMO_) && defined(_DEBUG)
    debug.logLevelMessage(LogLevel::LOG_INFO, L"[DEMO] === CLEANUP OPERATIONS ===");
#endif

    // Clean up temporary files created during demonstration
    DemonstrateDeleteFile("demo_output.txt", FileIOPriority::PRIORITY_LOW);
    DemonstrateDeleteFile("demo_compressed.dat", FileIOPriority::PRIORITY_LOW);
    DemonstrateDeleteFile("demo_low_priority.txt", FileIOPriority::PRIORITY_LOW);
    DemonstrateDeleteFile("demo_normal_priority.txt", FileIOPriority::PRIORITY_LOW);
    DemonstrateDeleteFile("demo_high_priority.txt", FileIOPriority::PRIORITY_LOW);
    DemonstrateDeleteFile("demo_critical_priority.txt", FileIOPriority::PRIORITY_LOW);

    // Allow time for cleanup operations to complete
    std::this_thread::sleep_for(std::chrono::seconds(2));

    // Clean up FileIO system
    CleanupFileIOSystem();

#if defined(_DEBUG_FILEIO_DEMO_) && defined(_DEBUG)
    debug.logLevelMessage(LogLevel::LOG_INFO, L"[DEMO] Comprehensive FileIO demonstration completed successfully");
#endif
}

//==============================================================================
// Usage Documentation and Best Practices
//==============================================================================

/*
FILEIO CLASS USAGE DOCUMENTATION
================================

INITIALIZATION:
1. Create FileIO instance: FileIO fileIO;
2. Initialize system: fileIO.Initialize();
3. Start processing thread: fileIO.StartFileIOThread();

BASIC FILE OPERATIONS:
- Check existence: fileIO.FileExists(filename, exists, priority, taskID);
- Get file size: fileIO.GetFileSize(filename, size, priority, taskID);
- Delete file: fileIO.DeleteFile(filename, priority, taskID);

FILE CONTENT OPERATIONS:
- Write file: fileIO.StreamWriteFile(filename, data, useCompression, priority, taskID);
- Read file: fileIO.StreamReadFile(filename, data, useDecompression, priority, taskID);
- Append data: fileIO.AppendToFile(filename, data, fileType, position, priority, taskID);

FILE MANAGEMENT:
- Copy file: fileIO.CopyFileTo(source, destination, priority, taskID);
- Move file: fileIO.MoveFileTo(source, destinationPath, priority, taskID);
- Rename file: fileIO.RenameFile(oldName, newName, priority, taskID);

TASK MONITORING:
- Check completion: fileIO.IsFileIOTaskCompleted(taskID, success, ready);
- Get error status: fileIO.GetErrorStatus(taskID);

QUEUE MANAGEMENT:
- Get queue size: fileIO.GetQueueSize();
- Clear queue: fileIO.ClearQueue();
- Check if empty: fileIO.IsQueueEmpty();

STATISTICS:
- Get statistics: fileIO.GetStatistics();
- Reset statistics: fileIO.ResetStatistics();

CLEANUP:
1. Stop thread: fileIO.StopFileIOThread();
2. Cleanup system: fileIO.Cleanup();

PRIORITY LEVELS:
- PRIORITY_LOW: Background operations
- PRIORITY_NORMAL: Standard operations
- PRIORITY_HIGH: Important operations  
- PRIORITY_CRITICAL: Urgent operations

COMPRESSION:
- Enable compression by setting shouldPack/shouldUnpack to true
- Uses PUNPack system for automatic compression/decompression
- Suitable for large files or repetitive data

ERROR HANDLING:
- All operations return task IDs for monitoring
- Check task completion status regularly
- Retrieve detailed error information using GetErrorStatus()
- Implement appropriate recovery strategies based on error types

THREAD SAFETY:
- All operations are thread-safe
- Uses ThreadManager and ThreadLockHelper for synchronization
- Asynchronous processing prevents UI blocking

BEST PRACTICES:
1. Always initialize FileIO before use
2. Monitor task completion for critical operations
3. Handle errors appropriately based on error type
4. Use appropriate priority levels for operations
5. Clean up system during application shutdown
6. Use compression for large or repetitive data
7. Avoid clearing queue unless necessary
8. Monitor statistics for performance optimization
*/