//==============================================================================
// Final Implementation Notes and Usage Examples
//==============================================================================

/*
USAGE EXAMPLE:

// Initialize the AI system
AIModelConfiguration config;
config.maxModelSizeBytes = 512 * 1024 * 1024;  // 512MB
config.analysisIntervalSeconds = 30;            // 30 second analysis
config.enableRealTimeAnalysis = true;

if (!gamingAI.Initialize(config)) {
    // Handle initialization failure
    return false;
}

// Start monitoring player behavior
if (!gamingAI.StartMonitoring()) {
    // Handle monitoring failure
    return false;
}

// During gameplay, collect player data
gamingAI.CollectPlayerPositionData(playerID, playerPosition);
gamingAI.CollectInputEventData(INPUT_TYPE_KEYBOARD, keyCode);

// Inject analysis commands
gamingAI.InjectAICommand(AICommandType::CMD_ANALYZE_PLAYER_MOVEMENT,
                        AICommandPriority::PRIORITY_HIGH, playerID);

// Get analysis results
AIAnalysisResult results = gamingAI.ReturnAIAnalysis();
if (results.isAnalysisValid) {
    // Use results for enemy AI strategy
    float difficulty = results.overallDifficultyRecommendation;
    EnemyAIStrategy strategy = results.recommendedStrategy;
}

// Stop monitoring and cleanup
gamingAI.EndMonitoring();
gamingAI.Cleanup();
*/

=================================================================
DETAILED BREAK DOWN
=================================================================
STEP 1

// Include required headers (already in your base set)
#include "GamingAI.h"

// Create GamingAI instance (should be global as per your base design)
GamingAI gamingAI;

// Initialize with custom configuration
AIModelConfiguration config;
config.maxModelSizeBytes = 256 * 1024 * 1024;        // 256MB model size limit
config.analysisIntervalSeconds = 15;                  // Analyze every 15 seconds
config.dataRetentionDays = 7.0f;                     // Keep data for 7 days
config.enableAdvancedPrediction = true;              // Enable advanced prediction algorithms
config.enableCrossSessionLearning = true;            // Learn across game sessions
config.learningRate = 0.15f;                         // Moderate learning rate
config.maxPlayerHistoryEntries = 500;                // 500 position history entries per player
config.enableRealTimeAnalysis = true;                // Enable real-time analysis

// Initialize the AI system
if (!gamingAI.Initialize(config)) {
    #if defined(_DEBUG_GAMINGAI_) && defined(_DEBUG)
        debug.logLevelMessage(LogLevel::LOG_CRITICAL, L"Failed to initialize GamingAI system!");
    #endif
    return EXIT_FAILURE;
}

=================================================================
STEP 2. Starting Player Behavior Monitoring
To begin collecting player data for analysis:

// Start monitoring player behavior
if (!gamingAI.StartMonitoring()) {
    #if defined(_DEBUG_GAMINGAI_) && defined(_DEBUG)
        debug.logLevelMessage(LogLevel::LOG_ERROR, L"Failed to start player behavior monitoring");
    #endif
    return false;
}

#if defined(_DEBUG_GAMINGAI_) && defined(_DEBUG)
    debug.logLevelMessage(LogLevel::LOG_INFO, L"GamingAI monitoring started successfully");
#endif

=================================================================
STEP 3: Real-Time Data Collection During Gameplay
The GamingAI system collects data automatically, but you need to feed it player position and input data:

// In your main game loop, collect player position data
void UpdateGameLoop() {
    // Get active players from GamePlayer system
    std::vector<int> activePlayerIDs = gamePlayer.GetActivePlayerIDs();
    
    for (int playerID : activePlayerIDs) {
        const PlayerInfo* playerInfo = gamePlayer.GetPlayerInfo(playerID);
        if (playerInfo != nullptr && playerInfo->isActive) {
            // Feed current player position to AI for analysis
            gamingAI.CollectPlayerPositionData(
                static_cast<uint32_t>(playerID), 
                playerInfo->position2D
            );
            
            #if defined(_DEBUG_GAMINGAI_) && defined(_DEBUG)
                debug.logDebugMessage(LogLevel::LOG_DEBUG, 
                    L"Collected position data for player %d: (%.2f, %.2f)", 
                    playerID, playerInfo->position2D.x, playerInfo->position2D.y);
            #endif
        }
    }
}

// In your input handling system, collect input events
void HandleKeyboardInput(WPARAM key, bool isPressed) {
    if (isPressed) {
        // Feed keyboard input data to AI
        gamingAI.CollectInputEventData(INPUT_TYPE_KEYBOARD, static_cast<uint32_t>(key));
        
        #if defined(_DEBUG_GAMINGAI_) && defined(_DEBUG)
            debug.logDebugMessage(LogLevel::LOG_DEBUG, L"Collected keyboard input: key 0x%X", key);
        #endif
    }
}

void HandleMouseInput(int button, bool isPressed) {
    if (isPressed) {
        // Feed mouse input data to AI
        gamingAI.CollectInputEventData(INPUT_TYPE_MOUSE, static_cast<uint32_t>(button));
        
        #if defined(_DEBUG_GAMINGAI_) && defined(_DEBUG)
            debug.logDebugMessage(LogLevel::LOG_DEBUG, L"Collected mouse input: button %d", button);
        #endif
    }
}

void HandleJoystickInput(int joystickID, uint32_t inputValue) {
    // Feed joystick input data to AI
    gamingAI.CollectInputEventData(INPUT_TYPE_JOYSTICK, inputValue);
    
    #if defined(_DEBUG_GAMINGAI_) && defined(_DEBUG)
        debug.logDebugMessage(LogLevel::LOG_DEBUG, L"Collected joystick input: value 0x%X", inputValue);
    #endif
}

=================================================================
STEP 4: Injecting AI Commands for Analysis
Use the command system to request specific analyses:

// Request immediate player movement analysis
bool RequestMovementAnalysis(uint32_t playerID = 0) {
    if (!gamingAI.InjectAICommand(
        AICommandType::CMD_ANALYZE_PLAYER_MOVEMENT, 
        AICommandPriority::PRIORITY_HIGH, 
        playerID)) {
        
        #if defined(_DEBUG_GAMINGAI_) && defined(_DEBUG)
            debug.logDebugMessage(LogLevel::LOG_ERROR, 
                L"Failed to inject movement analysis command for player %u", playerID);
        #endif
        return false;
    }
    
    #if defined(_DEBUG_GAMINGAI_) && defined(_DEBUG)
        debug.logDebugMessage(LogLevel::LOG_INFO, 
            L"Movement analysis requested for player %u", playerID);
    #endif
    return true;
}

// Request comprehensive player analysis
bool RequestFullPlayerAnalysis() {
    bool allCommandsSuccessful = true;
    
    // Queue multiple analysis commands
    if (!gamingAI.InjectAICommand(AICommandType::CMD_ANALYZE_PLAYER_MOVEMENT, AICommandPriority::PRIORITY_HIGH)) {
        allCommandsSuccessful = false;
    }
    
    if (!gamingAI.InjectAICommand(AICommandType::CMD_ANALYZE_PLAYER_COMBAT, AICommandPriority::PRIORITY_HIGH)) {
        allCommandsSuccessful = false;
    }
    
    if (!gamingAI.InjectAICommand(AICommandType::CMD_ANALYZE_INPUT_PATTERNS, AICommandPriority::PRIORITY_HIGH)) {
        allCommandsSuccessful = false;
    }
    
    if (!gamingAI.InjectAICommand(AICommandType::CMD_GENERATE_ENEMY_STRATEGY, AICommandPriority::PRIORITY_CRITICAL)) {
        allCommandsSuccessful = false;
    }
    
    #if defined(_DEBUG_GAMINGAI_) && defined(_DEBUG)
        debug.logDebugMessage(LogLevel::LOG_INFO, 
            L"Full player analysis requested - Success: %s", 
            allCommandsSuccessful ? L"Yes" : L"Partial");
    #endif
    
    return allCommandsSuccessful;
}

// Request difficulty adjustment
bool RequestDifficultyUpdate() {
    if (!gamingAI.InjectAICommand(AICommandType::CMD_UPDATE_DIFFICULTY, AICommandPriority::PRIORITY_NORMAL)) {
        #if defined(_DEBUG_GAMINGAI_) && defined(_DEBUG)
            debug.logLevelMessage(LogLevel::LOG_ERROR, L"Failed to inject difficulty update command");
        #endif
        return false;
    }
    
    #if defined(_DEBUG_GAMINGAI_) && defined(_DEBUG)
        debug.logLevelMessage(LogLevel::LOG_INFO, L"Difficulty update requested");
    #endif
    return true;
}

=================================================================
STEP 5: Retrieving AI Analysis Results
Get comprehensive analysis results for enemy AI strategy:

// Get current AI analysis results
AIAnalysisResult GetCurrentAIAnalysis() {
    AIAnalysisResult analysis = gamingAI.ReturnAIAnalysis();
    
    if (!analysis.isAnalysisValid) {
        #if defined(_DEBUG_GAMINGAI_) && defined(_DEBUG)
            debug.logLevelMessage(LogLevel::LOG_WARNING, L"AI analysis results are not valid");
        #endif
        return analysis;
    }
    
    #if defined(_DEBUG_GAMINGAI_) && defined(_DEBUG)
        debug.logDebugMessage(LogLevel::LOG_INFO, 
            L"Retrieved AI analysis - Players: %u, Difficulty: %.3f, Valid: %s",
            analysis.analyzedPlayerCount, 
            analysis.overallDifficultyRecommendation,
            analysis.isAnalysisValid ? L"Yes" : L"No");
    #endif
    
    // Process individual player analysis
    for (const PlayerAnalysisData& playerData : analysis.playerAnalysis) {
        #if defined(_DEBUG_GAMINGAI_) && defined(_DEBUG)
            debug.logDebugMessage(LogLevel::LOG_DEBUG,
                L"Player %u: Skill=%u, Predictability=%.3f, Aggression=%.3f",
                playerData.playerID,
                playerData.skillLevel,
                playerData.movementData.movementPredictability,
                playerData.movementData.aggressivenessFactor);
        #endif
    }
    
    return analysis;
}

// Apply AI recommendations to enemy behavior
void ApplyEnemyAIStrategy(const AIAnalysisResult& analysis) {
    if (!analysis.isAnalysisValid) {
        return;
    }
    
    const EnemyAIStrategy& strategy = analysis.recommendedStrategy;
    
    // Apply difficulty settings
    float newDifficulty = analysis.overallDifficultyRecommendation;
    
    // Apply enemy count recommendations
    uint32_t recommendedEnemies = strategy.recommendedEnemyCount;
    
    // Apply tactical recommendations
    for (const std::string& tactic : strategy.recommendedTactics) {
        #if defined(_DEBUG_GAMINGAI_) && defined(_DEBUG)
            debug.logDebugMessage(LogLevel::LOG_INFO, 
                L"Applying tactic: %S", tactic.c_str());
        #endif
        
        // Implement specific tactics based on string recommendations
        if (tactic == "advanced_flanking") {
            // Enable advanced flanking AI behavior
        }
        else if (tactic == "coordinated_attacks") {
            // Enable coordinated enemy attacks
        }
        else if (tactic == "predictive_movement") {
            // Enable predictive enemy movement
        }
        // Add more tactical implementations as needed
    }
    
    #if defined(_DEBUG_GAMINGAI_) && defined(_DEBUG)
        debug.logDebugMessage(LogLevel::LOG_INFO,
            L"Applied AI strategy - Difficulty: %.3f, Enemies: %u, Tactics: %zu",
            newDifficulty, recommendedEnemies, strategy.recommendedTactics.size());
    #endif
}

=================================================================
STEP 6: Configuration Management
Update AI settings during runtime:

// Update specific configuration parameters
bool UpdateAIConfiguration() {
    // Get current configuration
    AIModelConfiguration currentConfig = gamingAI.GetConfiguration();
    
    // Modify specific parameters
    currentConfig.analysisIntervalSeconds = 20;              // Increase analysis interval
    currentConfig.learningRate = 0.2f;                      // Increase learning rate
    currentConfig.maxPlayerHistoryEntries = 750;            // Increase history size
    
    // Apply updated configuration
    if (!gamingAI.UpdateConfiguration(currentConfig)) {
        #if defined(_DEBUG_GAMINGAI_) && defined(_DEBUG)
            debug.logLevelMessage(LogLevel::LOG_ERROR, L"Failed to update AI configuration");
        #endif
        return false;
    }
    
    #if defined(_DEBUG_GAMINGAI_) && defined(_DEBUG)
        debug.logDebugMessage(LogLevel::LOG_INFO,
            L"AI configuration updated - Interval: %u, Learning rate: %.3f",
            currentConfig.analysisIntervalSeconds, currentConfig.learningRate);
    #endif
    
    return true;
}

// Update individual configuration parameters
bool UpdateSpecificParameter(const std::string& paramName, const std::string& value) {
    if (!gamingAI.UpdateConfigurationParameter(paramName, value)) {
        #if defined(_DEBUG_GAMINGAI_) && defined(_DEBUG)
            debug.logDebugMessage(LogLevel::LOG_ERROR,
                L"Failed to update parameter %S to %S", paramName.c_str(), value.c_str());
        #endif
        return false;
    }
    
    #if defined(_DEBUG_GAMINGAI_) && defined(_DEBUG)
        debug.logDebugMessage(LogLevel::LOG_INFO,
            L"Updated parameter %S to %S", paramName.c_str(), value.c_str());
    #endif
    
    return true;
}

=================================================================
STEP 7: Model Persistence
Save and load AI learning models:

// Save current AI model
bool SaveAIModel(const std::string& filename = "") {
    if (!gamingAI.SaveAIModel(filename)) {
        #if defined(_DEBUG_GAMINGAI_) && defined(_DEBUG)
            debug.logDebugMessage(LogLevel::LOG_ERROR, 
                L"Failed to save AI model to file: %S", 
                filename.empty() ? L"default" : std::wstring(filename.begin(), filename.end()).c_str());
        #endif
        return false;
    }
    
    #if defined(_DEBUG_GAMINGAI_) && defined(_DEBUG)
        debug.logDebugMessage(LogLevel::LOG_INFO,
            L"AI model saved successfully - Size: %zu bytes",
            gamingAI.GetCurrentModelSize());
    #endif
    
    return true;
}

// Load existing AI model
bool LoadAIModel(const std::string& filename = "") {
    if (!gamingAI.ModelFileExists(filename)) {
        #if defined(_DEBUG_GAMINGAI_) && defined(_DEBUG)
            debug.logDebugMessage(LogLevel::LOG_WARNING,
                L"AI model file does not exist: %S",
                filename.empty() ? L"default" : std::wstring(filename.begin(), filename.end()).c_str());
        #endif
        return false;
    }
    
    if (!gamingAI.LoadAIModel(filename)) {
        #if defined(_DEBUG_GAMINGAI_) && defined(_DEBUG)
            debug.logLevelMessage(LogLevel::LOG_ERROR, L"Failed to load AI model");
        #endif
        return false;
    }
    
    #if defined(_DEBUG_GAMINGAI_) && defined(_DEBUG)
        debug.logDebugMessage(LogLevel::LOG_INFO,
            L"AI model loaded successfully - Size: %zu bytes",
            gamingAI.GetCurrentModelSize());
    #endif
    
    return true;
}

=================================================================
STEP 8: Performance Monitoring
Monitor AI system performance:

// Get AI performance metrics
void DisplayAIPerformanceMetrics() {
    // Get basic performance data
    size_t modelSize = gamingAI.GetCurrentModelSize();
    uint64_t totalAnalysis = gamingAI.GetTotalAnalysisCount();
    std::chrono::milliseconds avgTime = gamingAI.GetAverageAnalysisTime();
    size_t queueSize = gamingAI.GetCommandQueueSize();
    
    // Get detailed thread performance
    float cpuUsage = 0.0f;
    uint64_t memoryUsage = 0;
    bool perfValid = gamingAI.GetThreadPerformanceMetrics(cpuUsage, memoryUsage);
    
    #if defined(_DEBUG_GAMINGAI_) && defined(_DEBUG)
        debug.logDebugMessage(LogLevel::LOG_INFO,
            L"AI Performance Metrics:");
        debug.logDebugMessage(LogLevel::LOG_INFO,
            L"  Model Size: %zu bytes (%.2f MB)",
            modelSize, static_cast<float>(modelSize) / (1024.0f * 1024.0f));
        debug.logDebugMessage(LogLevel::LOG_INFO,
            L"  Total Analysis: %llu operations", totalAnalysis);
        debug.logDebugMessage(LogLevel::LOG_INFO,
            L"  Average Time: %lld ms", avgTime.count());
        debug.logDebugMessage(LogLevel::LOG_INFO,
            L"  Queue Size: %zu commands", queueSize);
        
        if (perfValid) {
            debug.logDebugMessage(LogLevel::LOG_INFO,
                L"  CPU Usage: %.1f%%", cpuUsage * 100.0f);
            debug.logDebugMessage(LogLevel::LOG_INFO,
                L"  Memory Usage: %llu bytes", memoryUsage);
        }
    #endif
}

=================================================================
STEP 9: Proper Shutdown Sequence
Clean shutdown of the AI system:

// Shutdown GamingAI system properly
void ShutdownGamingAI() {
    #if defined(_DEBUG_GAMINGAI_) && defined(_DEBUG)
        debug.logLevelMessage(LogLevel::LOG_INFO, L"Beginning GamingAI shutdown sequence");
    #endif
    
    // Stop monitoring if active
    if (gamingAI.IsMonitoring()) {
        if (!gamingAI.EndMonitoring()) {
            #if defined(_DEBUG_GAMINGAI_) && defined(_DEBUG)
                debug.logLevelMessage(LogLevel::LOG_WARNING, L"Failed to properly end monitoring");
            #endif
        }
    }
    
    // Save current model before shutdown
    if (gamingAI.GetCurrentModelSize() > 0) {
        if (!SaveAIModel()) {
            #if defined(_DEBUG_GAMINGAI_) && defined(_DEBUG)
                debug.logLevelMessage(LogLevel::LOG_WARNING, L"Failed to save AI model during shutdown");
            #endif
        }
    }
    
    // Clear command queue
    gamingAI.ClearCommandQueue();
    
    // Perform cleanup
    gamingAI.Cleanup();
    
    #if defined(_DEBUG_GAMINGAI_) && defined(_DEBUG)
        debug.logLevelMessage(LogLevel::LOG_INFO, L"GamingAI shutdown completed");
    #endif
}

=================================================================
STEP 10: Integration with Game Loop
Integrate AI analysis with your main game loop:

// Add to your main game loop (in main.cpp, line ~300+ in SCENE_GAMEPLAY case)
case SceneType::SCENE_GAMEPLAY:
{
    // Existing gameplay code...
    guiManager.HandleAllInput(myMouseCoords, isLeftClicked);
    js.processJoystickInput();
    js.processJoystickMovement(PLAYER_1);
    
    // Add GamingAI integration here
    static std::chrono::steady_clock::time_point lastAIUpdate = std::chrono::steady_clock::now();
    auto currentTime = std::chrono::steady_clock::now();
    auto timeSinceAIUpdate = std::chrono::duration_cast<std::chrono::seconds>(currentTime - lastAIUpdate);
    
    // Update AI analysis every 30 seconds or when analysis is ready
    if (timeSinceAIUpdate.count() >= 30 || gamingAI.IsAnalysisReady()) {
        // Get current AI analysis
        AIAnalysisResult aiAnalysis = GetCurrentAIAnalysis();
        
        // Apply AI recommendations to enemy behavior
        if (aiAnalysis.isAnalysisValid) {
            ApplyEnemyAIStrategy(aiAnalysis);
        }
        
        lastAIUpdate = currentTime;
    }
    
    // Monitor AI performance periodically
    static int aiPerformanceCounter = 0;
    if (++aiPerformanceCounter >= 1800) {  // Every ~30 seconds at 60fps
        DisplayAIPerformanceMetrics();
        aiPerformanceCounter = 0;
    }
    
    // Existing gameplay code continues...
    break;
}

================
Key Usage Notes:
================
Thread Safety: The GamingAI class uses ThreadManager and ThreadLockHelper internally for thread safety

Performance: All mathematical operations use MathPrecalculation for optimal gaming performance

Memory Management: The system automatically manages memory and provides configurable limits

Data Persistence: Models are automatically saved/loaded with compression for efficiency

Real-time Operation: Designed for real-time gameplay with minimal performance impact

Scalability: Supports up to 8 players simultaneously with comprehensive analysis

This comprehensive guide provides production-ready implementation patterns for integrating the GamingAI system 
into your gaming engine while maintaining optimal performance and thread safety.